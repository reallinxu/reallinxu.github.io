---
title: "java多线程与高并发---(一)线程与锁基础"
tags:
  - java多线程与高并发
id: 1000
categories:
  - java多线程与高并发
date: 2019-12-28 20:00:00
---

## 线程基础
1. 进程与线程：进程是资源分配的最小单位，线程是程序执行的最小单位。
2. 启动线程的三种方式：1.继承Thread类；2.实现Runable接口；3.Executors.newCacheThread(本质为前两种之一)。
3. 线程的几个重要方法  
sleep：线程休息，TIMED_WAITING状态。   
yield：谦让的退出，让出一下cpu，重新等待，可能yield后又马上执行。  
join: 切换到其他线程运行，运行完了再执行当前线程，用来等待一个线程结束。可以保证线程按顺序执行。  
interrupt：中断线程，实际是设置一个中断标志，线程仍会继续运行。线程中断会抛出异常。  
interrupted：检测中断标志测试当前线程是够已经被中断，并清除中断标志。注意当前线程，主线程中直接用子线程thread.interrupted检测的是主线程，应该使用Thread.currentThread()。  
isInterrupted：测试线程是否被中断，不清除中断状态。  
stop：废弃，不建议使用。 
4. 线程的六种状态(可通过Thread.currentThread().getState()获取)  
NEW：线程刚创建  
RUNNABLE：在JVM中正在运行的线程，又分为Ready和Runing，Ready状态为在cpu等待队列中，cpu会切换线程，被切换掉的线程会被挂起，running才是正在执行  
BLOCKED：线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行  
WAITING：等待状态 
TIMED_WAITING：计时等待
TERMINATED：线程执行完毕，已经退出，不再可重新转为其他状态  
![线程状态图](/imgs/线程状态图.png)

## 锁基础
1. sychoronise关键字，锁住的是对象，不能锁定String常量（常量公用），Interger，Long等基础数据类型（超过一个值还会new 对象）。判断是hotpot64位地址的的前两位，子类重写父类方法，两个都加了sychoronised，锁住的都是this，同一个对象。程序中出现异常，默认锁会释放，这时可能会出现其他线程的乱入，获取了错误的数据。早起为重量级锁，直接通过os申请，后续升级为hospot通过对象的前两位markword标记这个线程id偏向锁,如果线程争用升级为自旋锁，自旋10次后升级为重量锁。
2. 自旋锁会耗费cpu资源，一般执行时间段，线程少使用，执行时间长线程比较多用系统锁。
3. 重入锁和不可重入锁：冲入锁，同一个线程允许进入，sychoronise必须是重入锁，比如子类集成父类后重写方法调用super，如果不可重复则无法执行。  
4. 公平锁和非公平锁  
在公平的锁中，如果有另一个线程持有锁或者有其他线程在等待队列中等待这个所，那么新发出的请求的线程将被放入到队列中。而非公平锁上，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中（此时和公平锁是一样的）。所以，它们的差别在于非公平锁会有更多的机会去抢占锁。非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。使用场景的话呢，其实还是和他们的属性一一相关，举个栗子：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁会给业务增强很多的可控制性。