---
title: "一些java题"
id: 111
categories:
  - notes
date: 2018-09-10 14:17:01
tags: notes
---

1. HashMap原理  
简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。
2. 线程池原理，参数配置
提交一个任务到线程池中，线程池的处理流程如下：
判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。  
线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。  
判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上限5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。
3. 多线程锁
4. Lock原理，synchronized原理，区别
![](https://i.imgur.com/vZkLVrT.jpg)
6. Dubbo，springcloud，grpc，限流，熔断，降级
7. 分布式锁
8. volitle关键字，原理
9. cms垃圾回收算法，和gc区别
10. jvm内存模型，堆内存划分
11. 大对象如何分配
12. equals，hashcode方法原理
13. 内存数据库
14. mybatis一级缓存，二级缓存
15. redis多路复用，如何分片
16. 创建线程的原理
17. currumenthashmap锁原理
18. thread和runnable区别
