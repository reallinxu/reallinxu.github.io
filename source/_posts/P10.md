---
title: " java8初识\t\t"
id: 156
categories:
  - 杂项
date: 2018-03-13 09:19:22
tags:
---

1. 接口里允许使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。默认方法可以直接使用。默认方法无法在lambda表达式内部被访问。(test1)

2. 一个所谓的函数式接口必须要有且仅有一个抽象方法声明。每个与之对应的lambda表达式必须要与抽象方法的声明相匹配。由于默认方法不是抽象的，因此你可以在你的函数式接口里任意添加默认方法。(test1)

3. Java8允许你通过::关键字获取方法或者构造函数的的引用。(test1)

4. 我们通过Person::new来创建一个Person类构造函数的引用。Java编译器会自动地选择合适的构造函数来匹配PersonFactory.create函数的签名，并选择正确的构造函数形式。(test2)

5. lambda表达式可以访问外部的final局部变量，变量并不需要一定是final，然而，在编译的时候被隐式地当做final变量来处理。(test2,test3)

6. lambda表达式可以访问全部变量。(test3)

7. 当一个函数不修改数据流的底层数据源，它就是无干扰的。即没有任何lambda表达式通过添加或删除修改元素。(test4)

8. 当一个函数的操作的执行是确定性的，它就是无状态的。即在上面的例子中，没有任何lambda表达式依赖于外部作用域中任何在操作过程中可变的变量或状态。(test4)

9. 数据流基础操作。(test5)

10. 数据流衔接操作只在终止操作调用时被执行。(test6)

11. 衔接操作是垂直进行的，数据流执行顺序研究.(test6)

12. Java8的数据流不能被复用。一旦你调用了任何终止操作，数据流就关闭了.(test7)

13. 要克服第10点这个限制，我们需要为每个我们想要执行的终止操作创建新的数据流调用链。例如，我们创建一个数据流供应器，来构建新的数据流，并且设置好所有衔接操作。(test7)

14. Executors类提供了便利的工厂方法来创建不同类型的 executor services。Executors必须显式的停止。(test8)

15. executor 可以返回一个Future类型的结果，它可以用来在稍后某个时间取出实际的结果。(test9)

PS:括号内为测试代码，代码地址：https://github.com/reallinxu/java8Test